
import React, { useState, useCallback, useMemo } from 'react';
import { generateSlideDataFromText } from './services/geminiService';
import { DEFAULT_CONFIG, THEMES } from './constants';
import type { SlideData, Config, TableSlide, ContentSlide } from './types';
import Header from './components/Header';
import ConfigPanel from './components/ConfigPanel';
import OutputPanel from './components/OutputPanel';
import { LoadingIcon } from './components/Icons';
import { getReadableTextColor } from './utils/colorUtils';

const enhanceConfig = (config: Config): Config => {
  const newColors = { ...config.COLORS };
  const whiteBg = newColors.background_white || '#FFFFFF';
  const grayBg = newColors.background_gray || '#F8F9FA';
  const preferredText = newColors.text_primary || '#000000';
  
  newColors.readable_text_on_white = getReadableTextColor(whiteBg, preferredText);
  newColors.readable_text_on_gray = getReadableTextColor(grayBg, preferredText);

  return { ...config, COLORS: newColors };
};

/**
 * Validates the generated slide data and sanitizes it.
 * Specifically, it transforms any empty table slides into content slides.
 * This function now primarily affects the PREVIEW, as the final script is generated by the AI.
 * @param slides The array of slide data generated by the AI.
 * @returns A sanitized array of slide data.
 */
const validateAndSanitizeSlideData = (slides: SlideData[]): SlideData[] => {
  return slides.map(slide => {
    if (slide.type === 'table') {
      const tableSlide = slide as TableSlide;
      const hasHeaders = tableSlide.headers && tableSlide.headers.length > 0 && tableSlide.headers.some(h => h && h.trim() !== '');
      const hasRows = tableSlide.rows && tableSlide.rows.length > 0 && tableSlide.rows.some(r => r && r.length > 0 && r.some(c => c && c.trim() !== ''));

      if (!hasHeaders && !hasRows) {
        // This is an empty table. Transform it into a meaningful content slide.
        const newContentSlide: ContentSlide = {
          type: 'content',
          title: tableSlide.title,
          subhead: tableSlide.subhead,
          points: [
            'AIが表形式を推奨しましたが、内容を抽出できませんでした。',
            'そのため、このスライドは箇条書き形式に自動変換されています。',
            '元のテキストに必要なデータが含まれているかご確認ください。'
          ],
          notes: tableSlide.notes || `This slide was automatically converted from an empty table. The original title was "${tableSlide.title}".`
        };
        return newContentSlide;
      }
    }
    return slide;
  });
};

/**
 * Extracts the slideData array from a full Google Apps Script string.
 * @param script The full GAS script content.
 * @returns An array of SlideData objects, or null if not found/parsed.
 */
const extractSlideDataFromScript = (script: string): SlideData[] | null => {
  try {
    const match = script.match(/const slideData\s*=\s*(\[[\s\S]*?\]);/);
    if (!match || !match[1]) {
      console.error("Could not find slideData in the generated script.");
      return null;
    }
    const slideDataString = match[1];
    const slides = (new Function(`return ${slideDataString}`))();
    if (!Array.isArray(slides)) {
       console.error("Parsed slideData is not an array.");
       return null;
    }
    return slides as SlideData[];
  } catch (e) {
    console.error("Failed to parse extracted slideData:", e);
    return null;
  }
};


const STEPS = [
  { id: 1, title: 'コンテンツ入力' },
  { id: 2, title: 'デザイン調整' },
  { id: 3, title: '結果確認' },
];

const App: React.FC = () => {
  const [currentStep, setCurrentStep] = useState(1);
  const [inputText, setInputText] = useState('');
  const [config, setConfig] = useState<Config>(() => enhanceConfig(DEFAULT_CONFIG));
  const [generatedScript, setGeneratedScript] = useState<string>('');
  const [parsedSlideData, setParsedSlideData] = useState<SlideData[] | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const handleThemeChange = (themeName: string) => {
    const theme = THEMES.find(t => t.name === themeName);
    if (theme) {
      setConfig(prevConfig => enhanceConfig({
        ...prevConfig, 
        COLORS: {
          ...prevConfig.COLORS,
          ...theme.colors
        }
      }));
    }
  };

  const updateConfig = (updater: React.SetStateAction<Config>) => {
      setConfig(prev => {
          const newConfig = typeof updater === 'function' ? updater(prev) : updater;
          return enhanceConfig(newConfig);
      });
  };

  const handleGenerate = useCallback(async () => {
    if (!inputText.trim()) {
      setError('スライドを生成するには、テキストを入力してください。');
      return;
    }
    setIsLoading(true);
    setError(null);
    setGeneratedScript('');
    setParsedSlideData(null);
    setCurrentStep(3);

    try {
      const fullScript = await generateSlideDataFromText(inputText);
      setGeneratedScript(fullScript);
      
      const extractedSlides = extractSlideDataFromScript(fullScript);
      
      if (extractedSlides) {
        const sanitizedSlides = validateAndSanitizeSlideData(extractedSlides);
        setParsedSlideData(sanitizedSlides);
      } else {
        setParsedSlideData(null);
        throw new Error("生成されたスクリプトからスライドデータを抽出できませんでした。プレビューは表示できませんが、生成されたコードは利用可能です。AIの出力形式に問題があった可能性があります。");
      }
      
    } catch (e) {
      if (e instanceof Error) {
        setError(e.message);
      } else {
        setError('不明なエラーが発生しました。');
      }
    } finally {
      setIsLoading(false);
    }
  }, [inputText]);

  const handleReset = () => {
    setCurrentStep(1);
    setInputText('');
    setGeneratedScript('');
    setParsedSlideData(null);
    setError(null);
  };
  
  const StepIndicator = useMemo(() => (
    <div className="flex items-center justify-center mb-8">
      {STEPS.map((step, index) => (
        <React.Fragment key={step.id}>
          <div className="flex items-center">
            <div className={`w-8 h-8 rounded-full flex items-center justify-center font-bold transition-colors ${currentStep >= step.id ? 'bg-g-blue text-white' : 'bg-gray-200 dark:bg-gray-700 text-gray-500 dark:text-gray-400'}`}>
              {step.id}
            </div>
            <span className={`ml-3 font-semibold ${currentStep >= step.id ? 'text-gray-800 dark:text-gray-200' : 'text-gray-500 dark:text-gray-400'}`}>{step.title}</span>
          </div>
          {index < STEPS.length - 1 && <div className="flex-1 h-0.5 mx-4 bg-gray-200 dark:bg-gray-700"></div>}
        </React.Fragment>
      ))}
    </div>
  ), [currentStep]);
  
  const renderStepContent = () => {
    switch (currentStep) {
      case 1:
        return (
          <div className="max-w-3xl mx-auto bg-white dark:bg-gray-800 rounded-lg shadow p-8 transition-opacity duration-500 animate-fade-in">
            <h2 className="text-2xl font-bold mb-4 text-gray-900 dark:text-white">1. スクリプトの元になるテキストを入力</h2>
            <p className="mb-6 text-gray-600 dark:text-gray-400">Googleスライドを自動生成するスクリプトの元になる、会議のメモやアイデアなどを貼り付けてください。</p>
            <textarea
              value={inputText}
              onChange={(e) => setInputText(e.target.value)}
              placeholder="ここにテキストを貼り付け..."
              className="w-full h-80 p-4 border border-gray-300 dark:border-gray-600 rounded-md bg-gray-50 dark:bg-gray-700 focus:ring-2 focus:ring-g-blue focus:outline-none transition"
            />
            <button
              onClick={() => { if(inputText.trim()) setCurrentStep(2); else setError("テキストを入力してください。"); }}
              className="mt-6 w-full bg-g-blue hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center transition-colors disabled:bg-gray-400"
              disabled={!inputText.trim()}
            >
              次へ：スクリプト設定
            </button>
            {error && !inputText.trim() && <p className="text-g-red mt-4 text-sm text-center">{error}</p>}
          </div>
        );
      case 2:
        return (
          <div className="max-w-3xl mx-auto transition-opacity duration-500 animate-fade-in">
             <ConfigPanel 
                config={config} 
                setConfig={updateConfig} 
                onThemeChange={handleThemeChange} 
              />
              <div className="mt-6 flex gap-4">
                 <button
                  onClick={() => setCurrentStep(1)}
                  className="w-full bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 text-gray-800 dark:text-gray-200 font-bold py-3 px-4 rounded-lg transition-colors"
                >
                  戻る
                </button>
                <button
                  onClick={handleGenerate}
                  disabled={isLoading}
                  className="w-full bg-g-blue hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg flex items-center justify-center transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
                >
                  {isLoading ? <><LoadingIcon /> 生成中...</> : 'Google Apps Scriptを生成'}
                </button>
              </div>
          </div>
        );
      case 3:
        return (
          <div className="max-w-7xl mx-auto transition-opacity duration-500 animate-fade-in">
             <OutputPanel 
              generatedScript={generatedScript}
              slideData={parsedSlideData}
              config={config}
              isLoading={isLoading}
              error={error}
            />
            {!isLoading && (
              <div className="mt-8 text-center">
                <button
                  onClick={handleReset}
                  className="bg-g-green hover:bg-green-600 text-white font-bold py-3 px-6 rounded-lg transition-colors"
                >
                  新しいスクリプトを作成する
                </button>
              </div>
            )}
          </div>
        );
      default:
        return null;
    }
  }

  return (
    <div className="min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 font-sans">
      <Header />
      <main className="p-4 sm:p-6 lg:p-8">
        {StepIndicator}
        {renderStepContent()}
      </main>
    </div>
  );
};

export default App;
